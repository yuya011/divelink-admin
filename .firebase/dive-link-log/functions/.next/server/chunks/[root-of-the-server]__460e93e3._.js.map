{"version":3,"sources":["../../../../../../Desktop/Univ.local/admin/src/lib/firebase-admin.ts","../../../../../../Desktop/Univ.local/admin/node_modules/next/src/shared/lib/action-revalidation-kind.ts","../../../../../../Desktop/Univ.local/admin/node_modules/next/src/server/web/spec-extension/adapters/request-cookies.ts","../../../../../../Desktop/Univ.local/admin/node_modules/next/src/server/create-deduped-by-callsite-server-error-logger.ts","../../../../../../Desktop/Univ.local/admin/node_modules/next/src/server/request/cookies.ts","../../../../../../Desktop/Univ.local/admin/node_modules/next/src/server/web/spec-extension/adapters/headers.ts","../../../../../../Desktop/Univ.local/admin/node_modules/next/src/server/request/headers.ts","../../../../../../Desktop/Univ.local/admin/node_modules/next/src/server/request/draft-mode.ts","../../../../../../Desktop/Univ.local/admin/node_modules/next/headers.js","../../../../../../Desktop/Univ.local/admin/src/lib/auth.ts"],"sourcesContent":["import { initializeApp, getApps, cert, App } from 'firebase-admin/app';\nimport { getFirestore, Firestore } from 'firebase-admin/firestore';\nimport { getAuth, Auth } from 'firebase-admin/auth';\nimport { getMessaging, Messaging } from 'firebase-admin/messaging';\n\nlet app: App | undefined;\nlet db: Firestore | undefined;\nlet auth: Auth | undefined;\nlet messaging: Messaging | undefined;\n\nfunction getFirebaseApp(): App {\n    if (app) return app;\n\n    const apps = getApps();\n    if (apps.length > 0) {\n        app = apps[0];\n        return app;\n    }\n\n    const projectId = process.env.FB_PROJECT_ID;\n    const clientEmail = process.env.FB_CLIENT_EMAIL;\n    // 秘密鍵の改行コード処理を改善\n    let privateKey = process.env.FB_PRIVATE_KEY;\n\n    if (privateKey) {\n        // ダブルクォートで囲まれている場合を考慮\n        if (privateKey.startsWith('\"') && privateKey.endsWith('\"')) {\n            privateKey = privateKey.slice(1, -1);\n        }\n        // リテラルな \\n を実際の改行に変換\n        privateKey = privateKey.replace(/\\\\n/g, '\\n');\n    }\n\n    if (!projectId || !clientEmail || !privateKey) {\n        console.error('Firebase Credentials Error:', {\n            hasProjectId: !!projectId,\n            hasClientEmail: !!clientEmail,\n            hasPrivateKey: !!privateKey\n        });\n        throw new Error(\n            'Missing Firebase credentials. Please check environment variables.'\n        );\n    }\n\n    try {\n        app = initializeApp({\n            credential: cert({\n                projectId,\n                clientEmail,\n                privateKey,\n            }),\n        });\n        console.log('Firebase Admin Initialized successfully');\n    } catch (error) {\n        console.error('Firebase Admin Initialization Error:', error);\n        throw error;\n    }\n\n    return app;\n}\n\nexport function getFirestoreAdmin(): Firestore {\n    if (db) return db;\n    getFirebaseApp();\n    db = getFirestore();\n    return db;\n}\n\nexport function getAuthAdmin(): Auth {\n    if (auth) return auth;\n    getFirebaseApp();\n    auth = getAuth();\n    return auth;\n}\n\nexport function getMessagingAdmin(): Messaging {\n    if (messaging) return messaging;\n    getFirebaseApp();\n    messaging = getMessaging();\n    return messaging;\n}\n\n// コレクション名定数\nexport const COLLECTIONS = {\n    USERS: 'users',\n    ADMINS: 'admins',\n    SHOP_APPLICATIONS: 'shop_applications',\n    REPORTS: 'reports',\n    SUPPORT_TICKETS: 'support_tickets',\n    NOTIFICATIONS_LOG: 'notifications_log',\n    ADMIN_AUDIT_LOG: 'admin_audit_log',\n    DIVE_LOGS: 'diveLogs',\n    SHOPS: 'shops',\n} as const;\n","export type ActionRevalidationKind = 0 | 1 | 2\n\nexport const ActionDidNotRevalidate = 0\nexport const ActionDidRevalidateStaticAndDynamic = 1\nexport const ActionDidRevalidateDynamicOnly = 2\n","import { RequestCookies } from '../cookies'\n\nimport { ResponseCookies } from '../cookies'\nimport { ReflectAdapter } from './reflect'\nimport { workAsyncStorage } from '../../../app-render/work-async-storage.external'\nimport type { RequestStore } from '../../../app-render/work-unit-async-storage.external'\nimport { ActionDidRevalidateStaticAndDynamic } from '../../../../shared/lib/action-revalidation-kind'\n\n/**\n * @internal\n */\nexport class ReadonlyRequestCookiesError extends Error {\n  constructor() {\n    super(\n      'Cookies can only be modified in a Server Action or Route Handler. Read more: https://nextjs.org/docs/app/api-reference/functions/cookies#options'\n    )\n  }\n\n  public static callable() {\n    throw new ReadonlyRequestCookiesError()\n  }\n}\n\n// We use this to type some APIs but we don't construct instances directly\nexport type { ResponseCookies }\n\n// The `cookies()` API is a mix of request and response cookies. For `.get()` methods,\n// we want to return the request cookie if it exists. For mutative methods like `.set()`,\n// we want to return the response cookie.\nexport type ReadonlyRequestCookies = Omit<\n  RequestCookies,\n  'set' | 'clear' | 'delete'\n> &\n  Pick<ResponseCookies, 'set' | 'delete'>\n\nexport class RequestCookiesAdapter {\n  public static seal(cookies: RequestCookies): ReadonlyRequestCookies {\n    return new Proxy(cookies as any, {\n      get(target, prop, receiver) {\n        switch (prop) {\n          case 'clear':\n          case 'delete':\n          case 'set':\n            return ReadonlyRequestCookiesError.callable\n          default:\n            return ReflectAdapter.get(target, prop, receiver)\n        }\n      },\n    })\n  }\n}\n\nconst SYMBOL_MODIFY_COOKIE_VALUES = Symbol.for('next.mutated.cookies')\n\nexport function getModifiedCookieValues(\n  cookies: ResponseCookies\n): ResponseCookie[] {\n  const modified: ResponseCookie[] | undefined = (cookies as unknown as any)[\n    SYMBOL_MODIFY_COOKIE_VALUES\n  ]\n  if (!modified || !Array.isArray(modified) || modified.length === 0) {\n    return []\n  }\n\n  return modified\n}\n\ntype SetCookieArgs =\n  | [key: string, value: string, cookie?: Partial<ResponseCookie>]\n  | [options: ResponseCookie]\n\nexport function appendMutableCookies(\n  headers: Headers,\n  mutableCookies: ResponseCookies\n): boolean {\n  const modifiedCookieValues = getModifiedCookieValues(mutableCookies)\n  if (modifiedCookieValues.length === 0) {\n    return false\n  }\n\n  // Return a new response that extends the response with\n  // the modified cookies as fallbacks. `res` cookies\n  // will still take precedence.\n  const resCookies = new ResponseCookies(headers)\n  const returnedCookies = resCookies.getAll()\n\n  // Set the modified cookies as fallbacks.\n  for (const cookie of modifiedCookieValues) {\n    resCookies.set(cookie)\n  }\n\n  // Set the original cookies as the final values.\n  for (const cookie of returnedCookies) {\n    resCookies.set(cookie)\n  }\n\n  return true\n}\n\ntype ResponseCookie = NonNullable<\n  ReturnType<InstanceType<typeof ResponseCookies>['get']>\n>\n\nexport class MutableRequestCookiesAdapter {\n  public static wrap(\n    cookies: RequestCookies,\n    onUpdateCookies?: (cookies: string[]) => void\n  ): ResponseCookies {\n    const responseCookies = new ResponseCookies(new Headers())\n    for (const cookie of cookies.getAll()) {\n      responseCookies.set(cookie)\n    }\n\n    let modifiedValues: ResponseCookie[] = []\n    const modifiedCookies = new Set<string>()\n    const updateResponseCookies = () => {\n      // TODO-APP: change method of getting workStore\n      const workStore = workAsyncStorage.getStore()\n      if (workStore) {\n        workStore.pathWasRevalidated = ActionDidRevalidateStaticAndDynamic\n      }\n\n      const allCookies = responseCookies.getAll()\n      modifiedValues = allCookies.filter((c) => modifiedCookies.has(c.name))\n      if (onUpdateCookies) {\n        const serializedCookies: string[] = []\n        for (const cookie of modifiedValues) {\n          const tempCookies = new ResponseCookies(new Headers())\n          tempCookies.set(cookie)\n          serializedCookies.push(tempCookies.toString())\n        }\n\n        onUpdateCookies(serializedCookies)\n      }\n    }\n\n    const wrappedCookies = new Proxy(responseCookies, {\n      get(target, prop, receiver) {\n        switch (prop) {\n          // A special symbol to get the modified cookie values\n          case SYMBOL_MODIFY_COOKIE_VALUES:\n            return modifiedValues\n\n          // TODO: Throw error if trying to set a cookie after the response\n          // headers have been set.\n          case 'delete':\n            return function (...args: [string] | [ResponseCookie]) {\n              modifiedCookies.add(\n                typeof args[0] === 'string' ? args[0] : args[0].name\n              )\n              try {\n                target.delete(...args)\n                return wrappedCookies\n              } finally {\n                updateResponseCookies()\n              }\n            }\n          case 'set':\n            return function (...args: SetCookieArgs) {\n              modifiedCookies.add(\n                typeof args[0] === 'string' ? args[0] : args[0].name\n              )\n              try {\n                target.set(...args)\n                return wrappedCookies\n              } finally {\n                updateResponseCookies()\n              }\n            }\n\n          default:\n            return ReflectAdapter.get(target, prop, receiver)\n        }\n      },\n    })\n\n    return wrappedCookies\n  }\n}\n\nexport function createCookiesWithMutableAccessCheck(\n  requestStore: RequestStore\n): ResponseCookies {\n  const wrappedCookies = new Proxy(requestStore.mutableCookies, {\n    get(target, prop, receiver) {\n      switch (prop) {\n        case 'delete':\n          return function (...args: [string] | [ResponseCookie]) {\n            ensureCookiesAreStillMutable(requestStore, 'cookies().delete')\n            target.delete(...args)\n            return wrappedCookies\n          }\n        case 'set':\n          return function (...args: SetCookieArgs) {\n            ensureCookiesAreStillMutable(requestStore, 'cookies().set')\n            target.set(...args)\n            return wrappedCookies\n          }\n\n        default:\n          return ReflectAdapter.get(target, prop, receiver)\n      }\n    },\n  })\n  return wrappedCookies\n}\n\nexport function areCookiesMutableInCurrentPhase(requestStore: RequestStore) {\n  return requestStore.phase === 'action'\n}\n\n/** Ensure that cookies() starts throwing on mutation\n * if we changed phases and can no longer mutate.\n *\n * This can happen when going:\n *   'render' -> 'after'\n *   'action' -> 'render'\n * */\nfunction ensureCookiesAreStillMutable(\n  requestStore: RequestStore,\n  _callingExpression: string\n) {\n  if (!areCookiesMutableInCurrentPhase(requestStore)) {\n    // TODO: maybe we can give a more precise error message based on callingExpression?\n    throw new ReadonlyRequestCookiesError()\n  }\n}\n\nexport function responseCookiesToRequestCookies(\n  responseCookies: ResponseCookies\n): RequestCookies {\n  const requestCookies = new RequestCookies(new Headers())\n  for (const cookie of responseCookies.getAll()) {\n    requestCookies.set(cookie)\n  }\n  return requestCookies\n}\n","import * as React from 'react'\n\nconst errorRef: { current: null | Error } = { current: null }\n\n// React.cache is currently only available in canary/experimental React channels.\nconst cache =\n  typeof React.cache === 'function'\n    ? React.cache\n    : (fn: (key: unknown) => void) => fn\n\n// When Cache Components is enabled, we record these as errors so that they\n// are captured by the dev overlay as it's more critical to fix these\n// when enabled.\nconst logErrorOrWarn = process.env.__NEXT_CACHE_COMPONENTS\n  ? console.error\n  : console.warn\n\n// We don't want to dedupe across requests.\n// The developer might've just attempted to fix the warning so we should warn again if it still happens.\nconst flushCurrentErrorIfNew = cache(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars -- cache key\n  (key: unknown) => {\n    try {\n      logErrorOrWarn(errorRef.current)\n    } finally {\n      errorRef.current = null\n    }\n  }\n)\n\n/**\n * Creates a function that logs an error message that is deduped by the userland\n * callsite.\n * This requires no indirection between the call of this function and the userland\n * callsite i.e. there's only a single library frame above this.\n * Do not use on the Client where sourcemaps and ignore listing might be enabled.\n * Only use that for warnings need a fix independent of the callstack.\n *\n * @param getMessage\n * @returns\n */\nexport function createDedupedByCallsiteServerErrorLoggerDev<Args extends any[]>(\n  getMessage: (...args: Args) => Error\n) {\n  return function logDedupedError(...args: Args) {\n    const message = getMessage(...args)\n\n    if (process.env.NODE_ENV !== 'production') {\n      const callStackFrames = new Error().stack?.split('\\n')\n      if (callStackFrames === undefined || callStackFrames.length < 4) {\n        logErrorOrWarn(message)\n      } else {\n        // Error:\n        //   logDedupedError\n        //   asyncApiBeingAccessedSynchronously\n        //   <userland callsite>\n        // TODO: This breaks if sourcemaps with ignore lists are enabled.\n        const key = callStackFrames[4]\n        errorRef.current = message\n        flushCurrentErrorIfNew(key)\n      }\n    } else {\n      logErrorOrWarn(message)\n    }\n  }\n}\n","import {\n  type ReadonlyRequestCookies,\n  areCookiesMutableInCurrentPhase,\n  RequestCookiesAdapter,\n} from '../web/spec-extension/adapters/request-cookies'\nimport { RequestCookies } from '../web/spec-extension/cookies'\nimport {\n  workAsyncStorage,\n  type WorkStore,\n} from '../app-render/work-async-storage.external'\nimport {\n  throwForMissingRequestStore,\n  workUnitAsyncStorage,\n  type PrerenderStoreModern,\n  type RequestStore,\n} from '../app-render/work-unit-async-storage.external'\nimport {\n  delayUntilRuntimeStage,\n  postponeWithTracking,\n  throwToInterruptStaticGeneration,\n  trackDynamicDataInDynamicRender,\n} from '../app-render/dynamic-rendering'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport {\n  makeDevtoolsIOAwarePromise,\n  makeHangingPromise,\n} from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { isRequestAPICallableInsideAfter } from './utils'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { RenderStage } from '../app-render/staged-rendering'\n\nexport function cookies(): Promise<ReadonlyRequestCookies> {\n  const callingExpression = 'cookies'\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workStore) {\n    if (\n      workUnitStore &&\n      workUnitStore.phase === 'after' &&\n      !isRequestAPICallableInsideAfter()\n    ) {\n      throw new Error(\n        // TODO(after): clarify that this only applies to pages?\n        `Route ${workStore.route} used \\`cookies()\\` inside \\`after()\\`. This is not supported. If you need this data inside an \\`after()\\` callback, use \\`cookies()\\` outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`\n      )\n    }\n\n    if (workStore.forceStatic) {\n      // When using forceStatic we override all other logic and always just return an empty\n      // cookies object without tracking\n      const underlyingCookies = createEmptyCookies()\n      return makeUntrackedCookies(underlyingCookies)\n    }\n\n    if (workStore.dynamicShouldError) {\n      throw new StaticGenBailoutError(\n        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`cookies()\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n      )\n    }\n\n    if (workUnitStore) {\n      switch (workUnitStore.type) {\n        case 'cache':\n          const error = new Error(\n            `Route ${workStore.route} used \\`cookies()\\` inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`cookies()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n          )\n          Error.captureStackTrace(error, cookies)\n          workStore.invalidDynamicUsageError ??= error\n          throw error\n        case 'unstable-cache':\n          throw new Error(\n            `Route ${workStore.route} used \\`cookies()\\` inside a function cached with \\`unstable_cache()\\`. Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`cookies()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n          )\n        case 'prerender':\n          return makeHangingCookies(workStore, workUnitStore)\n        case 'prerender-client':\n          const exportName = '`cookies`'\n          throw new InvariantError(\n            `${exportName} must not be used within a Client Component. Next.js should be preventing ${exportName} from being included in Client Components statically, but did not in this case.`\n          )\n        case 'prerender-ppr':\n          // We need track dynamic access here eagerly to keep continuity with\n          // how cookies has worked in PPR without cacheComponents.\n          return postponeWithTracking(\n            workStore.route,\n            callingExpression,\n            workUnitStore.dynamicTracking\n          )\n        case 'prerender-legacy':\n          // We track dynamic access here so we don't need to wrap the cookies\n          // in individual property access tracking.\n          return throwToInterruptStaticGeneration(\n            callingExpression,\n            workStore,\n            workUnitStore\n          )\n        case 'prerender-runtime':\n          return delayUntilRuntimeStage(\n            workUnitStore,\n            makeUntrackedCookies(workUnitStore.cookies)\n          )\n        case 'private-cache':\n          // Private caches are delayed until the runtime stage in use-cache-wrapper,\n          // so we don't need an additional delay here.\n          return makeUntrackedCookies(workUnitStore.cookies)\n        case 'request':\n          trackDynamicDataInDynamicRender(workUnitStore)\n\n          let underlyingCookies: ReadonlyRequestCookies\n\n          if (areCookiesMutableInCurrentPhase(workUnitStore)) {\n            // We can't conditionally return different types here based on the context.\n            // To avoid confusion, we always return the readonly type here.\n            underlyingCookies =\n              workUnitStore.userspaceMutableCookies as unknown as ReadonlyRequestCookies\n          } else {\n            underlyingCookies = workUnitStore.cookies\n          }\n\n          if (process.env.NODE_ENV === 'development') {\n            // Semantically we only need the dev tracking when running in `next dev`\n            // but since you would never use next dev with production NODE_ENV we use this\n            // as a proxy so we can statically exclude this code from production builds.\n            return makeUntrackedCookiesWithDevWarnings(\n              workUnitStore,\n              underlyingCookies,\n              workStore?.route\n            )\n          } else {\n            return makeUntrackedCookies(underlyingCookies)\n          }\n        default:\n          workUnitStore satisfies never\n      }\n    }\n  }\n\n  // If we end up here, there was no work store or work unit store present.\n  throwForMissingRequestStore(callingExpression)\n}\n\nfunction createEmptyCookies(): ReadonlyRequestCookies {\n  return RequestCookiesAdapter.seal(new RequestCookies(new Headers({})))\n}\n\ninterface CacheLifetime {}\nconst CachedCookies = new WeakMap<\n  CacheLifetime,\n  Promise<ReadonlyRequestCookies>\n>()\n\nfunction makeHangingCookies(\n  workStore: WorkStore,\n  prerenderStore: PrerenderStoreModern\n): Promise<ReadonlyRequestCookies> {\n  const cachedPromise = CachedCookies.get(prerenderStore)\n  if (cachedPromise) {\n    return cachedPromise\n  }\n\n  const promise = makeHangingPromise<ReadonlyRequestCookies>(\n    prerenderStore.renderSignal,\n    workStore.route,\n    '`cookies()`'\n  )\n  CachedCookies.set(prerenderStore, promise)\n\n  return promise\n}\n\nfunction makeUntrackedCookies(\n  underlyingCookies: ReadonlyRequestCookies\n): Promise<ReadonlyRequestCookies> {\n  const cachedCookies = CachedCookies.get(underlyingCookies)\n  if (cachedCookies) {\n    return cachedCookies\n  }\n\n  const promise = Promise.resolve(underlyingCookies)\n  CachedCookies.set(underlyingCookies, promise)\n\n  return promise\n}\n\nfunction makeUntrackedCookiesWithDevWarnings(\n  requestStore: RequestStore,\n  underlyingCookies: ReadonlyRequestCookies,\n  route?: string\n): Promise<ReadonlyRequestCookies> {\n  if (requestStore.asyncApiPromises) {\n    let promise: Promise<ReadonlyRequestCookies>\n    if (underlyingCookies === requestStore.mutableCookies) {\n      promise = requestStore.asyncApiPromises.mutableCookies\n    } else if (underlyingCookies === requestStore.cookies) {\n      promise = requestStore.asyncApiPromises.cookies\n    } else {\n      throw new InvariantError(\n        'Received an underlying cookies object that does not match either `cookies` or `mutableCookies`'\n      )\n    }\n    return instrumentCookiesPromiseWithDevWarnings(promise, route)\n  }\n\n  const cachedCookies = CachedCookies.get(underlyingCookies)\n  if (cachedCookies) {\n    return cachedCookies\n  }\n\n  const promise = makeDevtoolsIOAwarePromise(\n    underlyingCookies,\n    requestStore,\n    RenderStage.Runtime\n  )\n\n  const proxiedPromise = instrumentCookiesPromiseWithDevWarnings(promise, route)\n\n  CachedCookies.set(underlyingCookies, proxiedPromise)\n\n  return proxiedPromise\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createCookiesAccessError\n)\n\nfunction instrumentCookiesPromiseWithDevWarnings(\n  promise: Promise<ReadonlyRequestCookies>,\n  route: string | undefined\n) {\n  Object.defineProperties(promise, {\n    [Symbol.iterator]: replaceableWarningDescriptorForSymbolIterator(\n      promise,\n      route\n    ),\n    size: replaceableWarningDescriptor(promise, 'size', route),\n    get: replaceableWarningDescriptor(promise, 'get', route),\n    getAll: replaceableWarningDescriptor(promise, 'getAll', route),\n    has: replaceableWarningDescriptor(promise, 'has', route),\n    set: replaceableWarningDescriptor(promise, 'set', route),\n    delete: replaceableWarningDescriptor(promise, 'delete', route),\n    clear: replaceableWarningDescriptor(promise, 'clear', route),\n    toString: replaceableWarningDescriptor(promise, 'toString', route),\n  })\n  return promise\n}\n\nfunction replaceableWarningDescriptor(\n  target: unknown,\n  prop: string,\n  route: string | undefined\n) {\n  return {\n    enumerable: false,\n    get() {\n      warnForSyncAccess(route, `\\`cookies().${prop}\\``)\n      return undefined\n    },\n    set(value: unknown) {\n      Object.defineProperty(target, prop, {\n        value,\n        writable: true,\n        configurable: true,\n      })\n    },\n    configurable: true,\n  }\n}\n\nfunction replaceableWarningDescriptorForSymbolIterator(\n  target: unknown,\n  route: string | undefined\n) {\n  return {\n    enumerable: false,\n    get() {\n      warnForSyncAccess(route, '`...cookies()` or similar iteration')\n      return undefined\n    },\n    set(value: unknown) {\n      Object.defineProperty(target, Symbol.iterator, {\n        value,\n        writable: true,\n        enumerable: true,\n        configurable: true,\n      })\n    },\n    configurable: true,\n  }\n}\n\nfunction createCookiesAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`cookies()\\` returns a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n","import type { IncomingHttpHeaders } from 'http'\n\nimport { ReflectAdapter } from './reflect'\n\n/**\n * @internal\n */\nexport class ReadonlyHeadersError extends Error {\n  constructor() {\n    super(\n      'Headers cannot be modified. Read more: https://nextjs.org/docs/app/api-reference/functions/headers'\n    )\n  }\n\n  public static callable() {\n    throw new ReadonlyHeadersError()\n  }\n}\n\nexport type ReadonlyHeaders = Headers & {\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  append(...args: any[]): void\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  set(...args: any[]): void\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  delete(...args: any[]): void\n}\nexport class HeadersAdapter extends Headers {\n  private readonly headers: IncomingHttpHeaders\n\n  constructor(headers: IncomingHttpHeaders) {\n    // We've already overridden the methods that would be called, so we're just\n    // calling the super constructor to ensure that the instanceof check works.\n    super()\n\n    this.headers = new Proxy(headers, {\n      get(target, prop, receiver) {\n        // Because this is just an object, we expect that all \"get\" operations\n        // are for properties. If it's a \"get\" for a symbol, we'll just return\n        // the symbol.\n        if (typeof prop === 'symbol') {\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, return undefined.\n        if (typeof original === 'undefined') return\n\n        // If the original casing exists, return the value.\n        return ReflectAdapter.get(target, original, receiver)\n      },\n      set(target, prop, value, receiver) {\n        if (typeof prop === 'symbol') {\n          return ReflectAdapter.set(target, prop, value, receiver)\n        }\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, use the prop as the key.\n        return ReflectAdapter.set(target, original ?? prop, value, receiver)\n      },\n      has(target, prop) {\n        if (typeof prop === 'symbol') return ReflectAdapter.has(target, prop)\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, return false.\n        if (typeof original === 'undefined') return false\n\n        // If the original casing exists, return true.\n        return ReflectAdapter.has(target, original)\n      },\n      deleteProperty(target, prop) {\n        if (typeof prop === 'symbol')\n          return ReflectAdapter.deleteProperty(target, prop)\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, return true.\n        if (typeof original === 'undefined') return true\n\n        // If the original casing exists, delete the property.\n        return ReflectAdapter.deleteProperty(target, original)\n      },\n    })\n  }\n\n  /**\n   * Seals a Headers instance to prevent modification by throwing an error when\n   * any mutating method is called.\n   */\n  public static seal(headers: Headers): ReadonlyHeaders {\n    return new Proxy<ReadonlyHeaders>(headers, {\n      get(target, prop, receiver) {\n        switch (prop) {\n          case 'append':\n          case 'delete':\n          case 'set':\n            return ReadonlyHeadersError.callable\n          default:\n            return ReflectAdapter.get(target, prop, receiver)\n        }\n      },\n    })\n  }\n\n  /**\n   * Merges a header value into a string. This stores multiple values as an\n   * array, so we need to merge them into a string.\n   *\n   * @param value a header value\n   * @returns a merged header value (a string)\n   */\n  private merge(value: string | string[]): string {\n    if (Array.isArray(value)) return value.join(', ')\n\n    return value\n  }\n\n  /**\n   * Creates a Headers instance from a plain object or a Headers instance.\n   *\n   * @param headers a plain object or a Headers instance\n   * @returns a headers instance\n   */\n  public static from(headers: IncomingHttpHeaders | Headers): Headers {\n    if (headers instanceof Headers) return headers\n\n    return new HeadersAdapter(headers)\n  }\n\n  public append(name: string, value: string): void {\n    const existing = this.headers[name]\n    if (typeof existing === 'string') {\n      this.headers[name] = [existing, value]\n    } else if (Array.isArray(existing)) {\n      existing.push(value)\n    } else {\n      this.headers[name] = value\n    }\n  }\n\n  public delete(name: string): void {\n    delete this.headers[name]\n  }\n\n  public get(name: string): string | null {\n    const value = this.headers[name]\n    if (typeof value !== 'undefined') return this.merge(value)\n\n    return null\n  }\n\n  public has(name: string): boolean {\n    return typeof this.headers[name] !== 'undefined'\n  }\n\n  public set(name: string, value: string): void {\n    this.headers[name] = value\n  }\n\n  public forEach(\n    callbackfn: (value: string, name: string, parent: Headers) => void,\n    thisArg?: any\n  ): void {\n    for (const [name, value] of this.entries()) {\n      callbackfn.call(thisArg, value, name, this)\n    }\n  }\n\n  public *entries(): HeadersIterator<[string, string]> {\n    for (const key of Object.keys(this.headers)) {\n      const name = key.toLowerCase()\n      // We assert here that this is a string because we got it from the\n      // Object.keys() call above.\n      const value = this.get(name) as string\n\n      yield [name, value] as [string, string]\n    }\n  }\n\n  public *keys(): HeadersIterator<string> {\n    for (const key of Object.keys(this.headers)) {\n      const name = key.toLowerCase()\n      yield name\n    }\n  }\n\n  public *values(): HeadersIterator<string> {\n    for (const key of Object.keys(this.headers)) {\n      // We assert here that this is a string because we got it from the\n      // Object.keys() call above.\n      const value = this.get(key) as string\n\n      yield value\n    }\n  }\n\n  public [Symbol.iterator](): HeadersIterator<[string, string]> {\n    return this.entries()\n  }\n}\n","import {\n  HeadersAdapter,\n  type ReadonlyHeaders,\n} from '../web/spec-extension/adapters/headers'\nimport {\n  workAsyncStorage,\n  type WorkStore,\n} from '../app-render/work-async-storage.external'\nimport {\n  throwForMissingRequestStore,\n  workUnitAsyncStorage,\n  type PrerenderStoreModern,\n  type RequestStore,\n} from '../app-render/work-unit-async-storage.external'\nimport {\n  delayUntilRuntimeStage,\n  postponeWithTracking,\n  throwToInterruptStaticGeneration,\n  trackDynamicDataInDynamicRender,\n} from '../app-render/dynamic-rendering'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport {\n  makeDevtoolsIOAwarePromise,\n  makeHangingPromise,\n} from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { isRequestAPICallableInsideAfter } from './utils'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { RenderStage } from '../app-render/staged-rendering'\n\n/**\n * This function allows you to read the HTTP incoming request headers in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers) and\n * [Middleware](https://nextjs.org/docs/app/building-your-application/routing/middleware).\n *\n * Read more: [Next.js Docs: `headers`](https://nextjs.org/docs/app/api-reference/functions/headers)\n */\nexport function headers(): Promise<ReadonlyHeaders> {\n  const callingExpression = 'headers'\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workStore) {\n    if (\n      workUnitStore &&\n      workUnitStore.phase === 'after' &&\n      !isRequestAPICallableInsideAfter()\n    ) {\n      throw new Error(\n        `Route ${workStore.route} used \\`headers()\\` inside \\`after()\\`. This is not supported. If you need this data inside an \\`after()\\` callback, use \\`headers()\\` outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`\n      )\n    }\n\n    if (workStore.forceStatic) {\n      // When using forceStatic we override all other logic and always just return an empty\n      // headers object without tracking\n      const underlyingHeaders = HeadersAdapter.seal(new Headers({}))\n      return makeUntrackedHeaders(underlyingHeaders)\n    }\n\n    if (workUnitStore) {\n      switch (workUnitStore.type) {\n        case 'cache': {\n          const error = new Error(\n            `Route ${workStore.route} used \\`headers()\\` inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`headers()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n          )\n          Error.captureStackTrace(error, headers)\n          workStore.invalidDynamicUsageError ??= error\n          throw error\n        }\n        case 'unstable-cache':\n          throw new Error(\n            `Route ${workStore.route} used \\`headers()\\` inside a function cached with \\`unstable_cache()\\`. Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`headers()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n          )\n        case 'prerender':\n        case 'prerender-client':\n        case 'private-cache':\n        case 'prerender-runtime':\n        case 'prerender-ppr':\n        case 'prerender-legacy':\n        case 'request':\n          break\n        default:\n          workUnitStore satisfies never\n      }\n    }\n\n    if (workStore.dynamicShouldError) {\n      throw new StaticGenBailoutError(\n        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`headers()\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n      )\n    }\n\n    if (workUnitStore) {\n      switch (workUnitStore.type) {\n        case 'prerender':\n          return makeHangingHeaders(workStore, workUnitStore)\n        case 'prerender-client':\n          const exportName = '`headers`'\n          throw new InvariantError(\n            `${exportName} must not be used within a client component. Next.js should be preventing ${exportName} from being included in client components statically, but did not in this case.`\n          )\n        case 'prerender-ppr':\n          // PPR Prerender (no cacheComponents)\n          // We are prerendering with PPR. We need track dynamic access here eagerly\n          // to keep continuity with how headers has worked in PPR without cacheComponents.\n          // TODO consider switching the semantic to throw on property access instead\n          return postponeWithTracking(\n            workStore.route,\n            callingExpression,\n            workUnitStore.dynamicTracking\n          )\n        case 'prerender-legacy':\n          // Legacy Prerender\n          // We are in a legacy static generation mode while prerendering\n          // We track dynamic access here so we don't need to wrap the headers in\n          // individual property access tracking.\n          return throwToInterruptStaticGeneration(\n            callingExpression,\n            workStore,\n            workUnitStore\n          )\n        case 'prerender-runtime':\n          return delayUntilRuntimeStage(\n            workUnitStore,\n            makeUntrackedHeaders(workUnitStore.headers)\n          )\n        case 'private-cache':\n          // Private caches are delayed until the runtime stage in use-cache-wrapper,\n          // so we don't need an additional delay here.\n          return makeUntrackedHeaders(workUnitStore.headers)\n        case 'request':\n          trackDynamicDataInDynamicRender(workUnitStore)\n\n          if (process.env.NODE_ENV === 'development') {\n            // Semantically we only need the dev tracking when running in `next dev`\n            // but since you would never use next dev with production NODE_ENV we use this\n            // as a proxy so we can statically exclude this code from production builds.\n            return makeUntrackedHeadersWithDevWarnings(\n              workUnitStore.headers,\n              workStore?.route,\n              workUnitStore\n            )\n          } else {\n            return makeUntrackedHeaders(workUnitStore.headers)\n          }\n          break\n        default:\n          workUnitStore satisfies never\n      }\n    }\n  }\n\n  // If we end up here, there was no work store or work unit store present.\n  throwForMissingRequestStore(callingExpression)\n}\n\ninterface CacheLifetime {}\nconst CachedHeaders = new WeakMap<CacheLifetime, Promise<ReadonlyHeaders>>()\n\nfunction makeHangingHeaders(\n  workStore: WorkStore,\n  prerenderStore: PrerenderStoreModern\n): Promise<ReadonlyHeaders> {\n  const cachedHeaders = CachedHeaders.get(prerenderStore)\n  if (cachedHeaders) {\n    return cachedHeaders\n  }\n\n  const promise = makeHangingPromise<ReadonlyHeaders>(\n    prerenderStore.renderSignal,\n    workStore.route,\n    '`headers()`'\n  )\n  CachedHeaders.set(prerenderStore, promise)\n\n  return promise\n}\n\nfunction makeUntrackedHeaders(\n  underlyingHeaders: ReadonlyHeaders\n): Promise<ReadonlyHeaders> {\n  const cachedHeaders = CachedHeaders.get(underlyingHeaders)\n  if (cachedHeaders) {\n    return cachedHeaders\n  }\n\n  const promise = Promise.resolve(underlyingHeaders)\n  CachedHeaders.set(underlyingHeaders, promise)\n\n  return promise\n}\n\nfunction makeUntrackedHeadersWithDevWarnings(\n  underlyingHeaders: ReadonlyHeaders,\n  route: string | undefined,\n  requestStore: RequestStore\n): Promise<ReadonlyHeaders> {\n  if (requestStore.asyncApiPromises) {\n    const promise = requestStore.asyncApiPromises.headers\n    return instrumentHeadersPromiseWithDevWarnings(promise, route)\n  }\n\n  const cachedHeaders = CachedHeaders.get(underlyingHeaders)\n  if (cachedHeaders) {\n    return cachedHeaders\n  }\n\n  const promise = makeDevtoolsIOAwarePromise(\n    underlyingHeaders,\n    requestStore,\n    RenderStage.Runtime\n  )\n\n  const proxiedPromise = instrumentHeadersPromiseWithDevWarnings(promise, route)\n\n  CachedHeaders.set(underlyingHeaders, proxiedPromise)\n\n  return proxiedPromise\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createHeadersAccessError\n)\n\nfunction instrumentHeadersPromiseWithDevWarnings(\n  promise: Promise<ReadonlyHeaders>,\n  route: string | undefined\n) {\n  Object.defineProperties(promise, {\n    [Symbol.iterator]: replaceableWarningDescriptorForSymbolIterator(\n      promise,\n      route\n    ),\n    append: replaceableWarningDescriptor(promise, 'append', route),\n    delete: replaceableWarningDescriptor(promise, 'delete', route),\n    get: replaceableWarningDescriptor(promise, 'get', route),\n    has: replaceableWarningDescriptor(promise, 'has', route),\n    set: replaceableWarningDescriptor(promise, 'set', route),\n    getSetCookie: replaceableWarningDescriptor(promise, 'getSetCookie', route),\n    forEach: replaceableWarningDescriptor(promise, 'forEach', route),\n    keys: replaceableWarningDescriptor(promise, 'keys', route),\n    values: replaceableWarningDescriptor(promise, 'values', route),\n    entries: replaceableWarningDescriptor(promise, 'entries', route),\n  })\n  return promise\n}\n\nfunction replaceableWarningDescriptor(\n  target: unknown,\n  prop: string,\n  route: string | undefined\n) {\n  return {\n    enumerable: false,\n    get() {\n      warnForSyncAccess(route, `\\`headers().${prop}\\``)\n      return undefined\n    },\n    set(value: unknown) {\n      Object.defineProperty(target, prop, {\n        value,\n        writable: true,\n        configurable: true,\n      })\n    },\n    configurable: true,\n  }\n}\n\nfunction replaceableWarningDescriptorForSymbolIterator(\n  target: unknown,\n  route: string | undefined\n) {\n  return {\n    enumerable: false,\n    get() {\n      warnForSyncAccess(route, '`...headers()` or similar iteration')\n      return undefined\n    },\n    set(value: unknown) {\n      Object.defineProperty(target, Symbol.iterator, {\n        value,\n        writable: true,\n        enumerable: true,\n        configurable: true,\n      })\n    },\n    configurable: true,\n  }\n}\n\nfunction createHeadersAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`headers()\\` returns a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n","import {\n  getDraftModeProviderForCacheScope,\n  throwForMissingRequestStore,\n} from '../app-render/work-unit-async-storage.external'\n\nimport type { DraftModeProvider } from '../async-storage/draft-mode-provider'\n\nimport {\n  workAsyncStorage,\n  type WorkStore,\n} from '../app-render/work-async-storage.external'\nimport { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'\nimport {\n  abortAndThrowOnSynchronousRequestDataAccess,\n  delayUntilRuntimeStage,\n  postponeWithTracking,\n  trackDynamicDataInDynamicRender,\n} from '../app-render/dynamic-rendering'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\n\nexport function draftMode(): Promise<DraftMode> {\n  const callingExpression = 'draftMode'\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (!workStore || !workUnitStore) {\n    throwForMissingRequestStore(callingExpression)\n  }\n\n  switch (workUnitStore.type) {\n    case 'prerender-runtime':\n      // TODO(runtime-ppr): does it make sense to delay this? normally it's always microtasky\n      return delayUntilRuntimeStage(\n        workUnitStore,\n        createOrGetCachedDraftMode(workUnitStore.draftMode, workStore)\n      )\n    case 'request':\n      return createOrGetCachedDraftMode(workUnitStore.draftMode, workStore)\n\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n      // Inside of `\"use cache\"` or `unstable_cache`, draft mode is available if\n      // the outmost work unit store is a request store (or a runtime prerender),\n      // and if draft mode is enabled.\n      const draftModeProvider = getDraftModeProviderForCacheScope(\n        workStore,\n        workUnitStore\n      )\n\n      if (draftModeProvider) {\n        return createOrGetCachedDraftMode(draftModeProvider, workStore)\n      }\n\n    // Otherwise, we fall through to providing an empty draft mode.\n    // eslint-disable-next-line no-fallthrough\n    case 'prerender':\n    case 'prerender-client':\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n      // Return empty draft mode\n      return createOrGetCachedDraftMode(null, workStore)\n\n    default:\n      return workUnitStore satisfies never\n  }\n}\n\nfunction createOrGetCachedDraftMode(\n  draftModeProvider: DraftModeProvider | null,\n  workStore: WorkStore | undefined\n): Promise<DraftMode> {\n  const cacheKey = draftModeProvider ?? NullDraftMode\n  const cachedDraftMode = CachedDraftModes.get(cacheKey)\n\n  if (cachedDraftMode) {\n    return cachedDraftMode\n  }\n\n  if (process.env.NODE_ENV === 'development' && !workStore?.isPrefetchRequest) {\n    const route = workStore?.route\n    return createDraftModeWithDevWarnings(draftModeProvider, route)\n  } else {\n    return Promise.resolve(new DraftMode(draftModeProvider))\n  }\n}\n\ninterface CacheLifetime {}\nconst NullDraftMode = {}\nconst CachedDraftModes = new WeakMap<CacheLifetime, Promise<DraftMode>>()\n\nfunction createDraftModeWithDevWarnings(\n  underlyingProvider: null | DraftModeProvider,\n  route: undefined | string\n): Promise<DraftMode> {\n  const instance = new DraftMode(underlyingProvider)\n  const promise = Promise.resolve(instance)\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      switch (prop) {\n        case 'isEnabled':\n          warnForSyncAccess(route, `\\`draftMode().${prop}\\``)\n          break\n        case 'enable':\n        case 'disable': {\n          warnForSyncAccess(route, `\\`draftMode().${prop}()\\``)\n          break\n        }\n        default: {\n          // We only warn for well-defined properties of the draftMode object.\n        }\n      }\n\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n  })\n\n  return proxiedPromise\n}\n\nclass DraftMode {\n  /**\n   * @internal - this declaration is stripped via `tsc --stripInternal`\n   */\n  private readonly _provider: null | DraftModeProvider\n\n  constructor(provider: null | DraftModeProvider) {\n    this._provider = provider\n  }\n  get isEnabled() {\n    if (this._provider !== null) {\n      return this._provider.isEnabled\n    }\n    return false\n  }\n  public enable() {\n    // We have a store we want to track dynamic data access to ensure we\n    // don't statically generate routes that manipulate draft mode.\n    trackDynamicDraftMode('draftMode().enable()', this.enable)\n    if (this._provider !== null) {\n      this._provider.enable()\n    }\n  }\n  public disable() {\n    trackDynamicDraftMode('draftMode().disable()', this.disable)\n    if (this._provider !== null) {\n      this._provider.disable()\n    }\n  }\n}\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createDraftModeAccessError\n)\n\nfunction createDraftModeAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`draftMode()\\` returns a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction trackDynamicDraftMode(expression: string, constructorOpt: Function) {\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workStore) {\n    // We have a store we want to track dynamic data access to ensure we\n    // don't statically generate routes that manipulate draft mode.\n    if (workUnitStore?.phase === 'after') {\n      throw new Error(\n        `Route ${workStore.route} used \"${expression}\" inside \\`after()\\`. The enabled status of \\`draftMode()\\` can be read inside \\`after()\\` but you cannot enable or disable \\`draftMode()\\`. See more info here: https://nextjs.org/docs/app/api-reference/functions/after`\n      )\n    }\n\n    if (workStore.dynamicShouldError) {\n      throw new StaticGenBailoutError(\n        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n      )\n    }\n\n    if (workUnitStore) {\n      switch (workUnitStore.type) {\n        case 'cache':\n        case 'private-cache': {\n          const error = new Error(\n            `Route ${workStore.route} used \"${expression}\" inside \"use cache\". The enabled status of \\`draftMode()\\` can be read in caches but you must not enable or disable \\`draftMode()\\` inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n          )\n          Error.captureStackTrace(error, constructorOpt)\n          workStore.invalidDynamicUsageError ??= error\n          throw error\n        }\n        case 'unstable-cache':\n          throw new Error(\n            `Route ${workStore.route} used \"${expression}\" inside a function cached with \\`unstable_cache()\\`. The enabled status of \\`draftMode()\\` can be read in caches but you must not enable or disable \\`draftMode()\\` inside a cache. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n          )\n\n        case 'prerender':\n        case 'prerender-runtime': {\n          const error = new Error(\n            `Route ${workStore.route} used ${expression} without first calling \\`await connection()\\`. See more info here: https://nextjs.org/docs/messages/next-prerender-sync-headers`\n          )\n          return abortAndThrowOnSynchronousRequestDataAccess(\n            workStore.route,\n            expression,\n            error,\n            workUnitStore\n          )\n        }\n        case 'prerender-client':\n          const exportName = '`draftMode`'\n          throw new InvariantError(\n            `${exportName} must not be used within a Client Component. Next.js should be preventing ${exportName} from being included in Client Components statically, but did not in this case.`\n          )\n        case 'prerender-ppr':\n          return postponeWithTracking(\n            workStore.route,\n            expression,\n            workUnitStore.dynamicTracking\n          )\n        case 'prerender-legacy':\n          workUnitStore.revalidate = 0\n\n          const err = new DynamicServerError(\n            `Route ${workStore.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n          )\n          workStore.dynamicUsageDescription = expression\n          workStore.dynamicUsageStack = err.stack\n\n          throw err\n        case 'request':\n          trackDynamicDataInDynamicRender(workUnitStore)\n          break\n        default:\n          workUnitStore satisfies never\n      }\n    }\n  }\n}\n","module.exports.cookies = require('./dist/server/request/cookies').cookies\nmodule.exports.headers = require('./dist/server/request/headers').headers\nmodule.exports.draftMode = require('./dist/server/request/draft-mode').draftMode\n","import { cookies } from 'next/headers';\nimport { getAuthAdmin, getFirestoreAdmin, COLLECTIONS } from './firebase-admin';\nimport type { Admin } from '@/types';\n\nconst SESSION_COOKIE_NAME = 'admin_session';\nconst SESSION_EXPIRY_DAYS = 5;\n\nexport async function createSessionCookie(idToken: string): Promise<string> {\n    const auth = getAuthAdmin();\n    const expiresIn = SESSION_EXPIRY_DAYS * 24 * 60 * 60 * 1000;\n\n    const sessionCookie = await auth.createSessionCookie(idToken, { expiresIn });\n    return sessionCookie;\n}\n\nexport async function verifySessionCookie(sessionCookie: string): Promise<{ uid: string; email: string } | null> {\n    try {\n        const auth = getAuthAdmin();\n        const decodedClaims = await auth.verifySessionCookie(sessionCookie, true);\n        return {\n            uid: decodedClaims.uid,\n            email: decodedClaims.email || '',\n        };\n    } catch {\n        return null;\n    }\n}\n\nexport async function getAdminFromSession(): Promise<Admin | null> {\n    const cookieStore = await cookies();\n    const sessionCookie = cookieStore.get(SESSION_COOKIE_NAME)?.value;\n\n    if (!sessionCookie) {\n        return null;\n    }\n\n    const user = await verifySessionCookie(sessionCookie);\n    if (!user) {\n        return null;\n    }\n\n    const db = getFirestoreAdmin();\n    const adminDoc = await db.collection(COLLECTIONS.ADMINS).doc(user.uid).get();\n\n    if (!adminDoc.exists) {\n        return null;\n    }\n\n    return {\n        uid: user.uid,\n        ...adminDoc.data(),\n    } as Admin;\n}\n\nexport async function isAuthenticated(): Promise<boolean> {\n    const admin = await getAdminFromSession();\n    return admin !== null;\n}\n\nexport async function hasPermission(requiredRole: 'super_admin' | 'admin' | 'moderator'): Promise<boolean> {\n    const admin = await getAdminFromSession();\n    if (!admin) return false;\n\n    const roleHierarchy = {\n        'super_admin': 3,\n        'admin': 2,\n        'moderator': 1,\n    };\n\n    return roleHierarchy[admin.role] >= roleHierarchy[requiredRole];\n}\n\nexport { SESSION_COOKIE_NAME };\n"],"names":["ActionDidNotRevalidate","ActionDidRevalidateDynamicOnly","ActionDidRevalidateStaticAndDynamic","MutableRequestCookiesAdapter","ReadonlyRequestCookiesError","RequestCookiesAdapter","appendMutableCookies","areCookiesMutableInCurrentPhase","createCookiesWithMutableAccessCheck","getModifiedCookieValues","responseCookiesToRequestCookies","Error","constructor","callable","seal","cookies","Proxy","get","target","prop","receiver","ReflectAdapter","SYMBOL_MODIFY_COOKIE_VALUES","Symbol","for","modified","Array","isArray","length","headers","mutableCookies","modifiedCookieValues","resCookies","ResponseCookies","returnedCookies","getAll","cookie","set","wrap","onUpdateCookies","responseCookies","Headers","modifiedValues","modifiedCookies","Set","updateResponseCookies","workStore","workAsyncStorage","getStore","pathWasRevalidated","allCookies","filter","c","has","name","serializedCookies","tempCookies","push","toString","wrappedCookies","args","add","delete","requestStore","ensureCookiesAreStillMutable","phase","_callingExpression","requestCookies","RequestCookies","createDedupedByCallsiteServerErrorLoggerDev","errorRef","current","cache","React","fn","logErrorOrWarn","process","env","__NEXT_CACHE_COMPONENTS","console","error","warn","flushCurrentErrorIfNew","key","getMessage","logDedupedError","message","NODE_ENV","callStackFrames","stack","split","undefined","callingExpression","workUnitStore","workUnitAsyncStorage","isRequestAPICallableInsideAfter","route","forceStatic","underlyingCookies","createEmptyCookies","makeUntrackedCookies","dynamicShouldError","StaticGenBailoutError","type","captureStackTrace","invalidDynamicUsageError","makeHangingCookies","exportName","InvariantError","postponeWithTracking","dynamicTracking","throwToInterruptStaticGeneration","delayUntilRuntimeStage","trackDynamicDataInDynamicRender","userspaceMutableCookies","makeUntrackedCookiesWithDevWarnings","throwForMissingRequestStore","CachedCookies","WeakMap","prerenderStore","cachedPromise","promise","makeHangingPromise","renderSignal","cachedCookies","Promise","resolve","asyncApiPromises","instrumentCookiesPromiseWithDevWarnings","makeDevtoolsIOAwarePromise","RenderStage","Runtime","proxiedPromise","warnForSyncAccess","createCookiesAccessError","Object","defineProperties","iterator","replaceableWarningDescriptorForSymbolIterator","size","replaceableWarningDescriptor","clear","enumerable","value","defineProperty","writable","configurable","expression","prefix","HeadersAdapter","ReadonlyHeadersError","lowercased","toLowerCase","original","keys","find","o","deleteProperty","merge","join","from","append","existing","forEach","callbackfn","thisArg","entries","call","values","underlyingHeaders","makeUntrackedHeaders","makeHangingHeaders","makeUntrackedHeadersWithDevWarnings","CachedHeaders","cachedHeaders","instrumentHeadersPromiseWithDevWarnings","createHeadersAccessError","getSetCookie","draftMode","createOrGetCachedDraftMode","draftModeProvider","getDraftModeProviderForCacheScope","cacheKey","NullDraftMode","cachedDraftMode","CachedDraftModes","isPrefetchRequest","createDraftModeWithDevWarnings","DraftMode","underlyingProvider","instance","provider","_provider","isEnabled","enable","trackDynamicDraftMode","disable","createDraftModeAccessError","constructorOpt","abortAndThrowOnSynchronousRequestDataAccess","revalidate","err","DynamicServerError","dynamicUsageDescription","dynamicUsageStack"],"mappings":"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","ignoreList":[1,2,3,4,5,6,7,8]}